# HTTP endpoints and request flows

## Summary
Domain: Shopping Cart REST API  
Business purpose: Provides basic cart management endpoints so clients can read, add, and remove items in a user's shopping cart; enables product-listing and simple cart operations for a shopping experience.  
Tags: rest, mongodb, routes

This subtopic documents the presentation-layer HTTP route handlers implemented in:
- `flask-shopping-cart-rest-api/api/api_routes.py` (Blueprint: `api_routes_bp`)  
Key exported route handlers / symbols: `home`, `get_items`, `get_item`, `add_item`, `remove_item`.

---

## Key Abstractions

- **Blueprint-based routing (Flask Blueprint)**  
  - Encapsulates related HTTP routes in `api_routes_bp`. Enables registration on an application instance (typically from `app.py`). Pattern: modular route grouping for the Presentation Layer.

- **DB-as-external-dependency (PyMongo-style `db`)**  
  - Route handlers use an externally provided `db` object (from `app.py`) to perform `find`, `find_one`, `insert_one`, and `find_one_and_delete`. This separates connection setup from request handling and enables easier testing/mocking.

- **Query-param-driven GET handlers (anti-pattern for mutations)**  
  - All handlers read `request.args` (query parameters) and use HTTP GET even for mutations (`addItem`, `removeItem`). This simplifies client calls but violates RESTful conventions and has cache/side-effect implications.

- **ObjectId conversion and serialization**  
  - BSON `_id` values are converted to strings when returning records. `get_item` currently stringifies the full document via `str(item)` (loses JSON fidelity). `add_item` parses user input unsafely (uses `eval`) before `insert_one`.

---

## Collaborative Use Case (how the code pieces interact)

Participants:
- Client (HTTP consumer)
- Flask app bootstrap (`app.py`) which creates application, registers blueprint, and exposes `db`
- File: `flask-shopping-cart-rest-api/api/api_routes.py` (`api_routes_bp`)
  - Symbols: `home`, `get_items`, `get_item`, `add_item`, `remove_item`
- MongoDB (via PyMongo `db.items` collection)

File-level collaboration (high-level):
- `app.py` initializes Flask and PyMongo `db` and registers `api_routes_bp`.
- Client sends HTTP GET requests to endpoints on `api_routes_bp`.
- Handlers read `request.args`, interact with `db.items`, and return JSON responses via `flask.json.jsonify`.

Example: how functions map to endpoints and DB calls
- `GET /getItems/` -> `get_items()` -> `db.items.find()` -> convert `_id` to string -> return `{"count": n, "items": [...]}`.
- `GET /getItemWithId?id=<id>` -> `get_item()` -> validate `ObjectId.is_valid(id)` -> `db.items.find_one({"_id": ObjectId(id)})` -> return found item or message.
- `GET /addItem?item=<py-literal>` -> `add_item()` -> `eval(item)` -> `db.items.insert_one(item)` -> return success message (unsafe).
- `GET /removeItem?id=<id>` -> `remove_item()` -> `db.items.find_one_and_delete({"_id": ObjectId(id)})` -> return success or not-found.

Concrete request/response examples (current implementation)

1) List items
Request:
```http
GET /getItems/
```
Response (200 JSON):
```json
{
  "count": 2,
  "items": [
    {"_id": "64f1a9e2...", "name": "apple", "price": 1},
    {"_id": "64f1a9f3...", "name": "banana", "price": 2}
  ]
}
```

2) Retrieve single item
Request:
```http
GET /getItemWithId?id=64f1a9e2...
```
Successful response (200 JSON):
```json
{
  "message": "Successfully found an item with that id",
  "item": "{'_id': ObjectId('64f1a9e2...'), 'name': 'apple', 'price': 1}"
}
```
Notes: `item` is returned as a `str(item)` (stringified Python dict), not structured JSON.

3) Add item (current unsafe form)
Request:
```http
GET /addItem?item={"name": "pear", "price": 3}
```
Server does:
```python
item = eval(request.args.get("item"))   # unsafe
db.items.insert_one(item)
```
Response (200 JSON):
```json
{
  "item": "{'_id': ObjectId('64f1aa00...'), 'name': 'pear', 'price': 3}",
  "message": "Item successfully added to the cart"
}
```

4) Remove item
Request:
```http
GET /removeItem?id=64f1a9e2...
```
Server does:
```python
db.items.find_one_and_delete({"_id": ObjectId(id)})
```
Responses:
- If deleted: `{"message": "Item removed successfully"}`
- If not found or id missing: a message JSON indicating the error

---

## Application Flow Integration

This module participates in the following flows:

1) Cart Management Flow (list all items)
- Endpoint: `GET /getItems/` → Handler: `get_items`
- Steps:
  - Query: `db.items.find()`
  - Transform: convert BSON `_id` to string
  - Return: structured JSON `{ "count": n, "items": [...] }`
- Error handling: returns empty list if none.

2) Item Retrieval Flow (single item by id)
- Endpoint: `GET /getItemWithId?id=<id>` → Handler: `get_item`
- Steps:
  - Validate `id` with `ObjectId.is_valid`
  - Query: `db.items.find_one({"_id": ObjectId(id)})`
  - Success: return message + `str(item)`
  - Failure cases:
    - Missing `id` → `{"message": "Please provide an id"}`
    - Invalid `id` → `{"message": "Not a valid id"}`
    - Not found → `{"message": "No item present with that id"}`

3) Item Addition Flow (add a new cart item)
- Endpoint: `GET /addItem?item=<py-literal>` → Handler: `add_item`
- Steps:
  - Read `item` query param
  - Parse user input via `eval(item)` (unsafe)
  - `db.items.insert_one(item)`
  - Return success message + `str(item)`
- Failure case: missing `item` param → `{"message": "No item provided to add"}`

4) Item Removal Flow (delete item by id)
- Endpoint: `GET /removeItem?id=<id>` → Handler: `remove_item`
- Steps:
  - Convert `id` to `ObjectId` (no prior `is_valid` check)
  - `db.items.find_one_and_delete({"_id": ObjectId(id)})`
  - Return success or not-found message
- Failure cases:
  - Missing `id` → `{"message": "No item id is provided to delete"}`
  - Invalid `id` may raise exception (no validation in current code)

---

## Visual Diagrams

### 1) File collaboration (blueprint registration and runtime dependencies)
```mermaid
graph TD
    Client["Client (HTTP)"] --> API["flask-shopping-cart-rest-api/api/api_routes.py\n(api_routes_bp)"]
    AppPy["app.py\n(Flask Bootstrap)"] --> API
    AppPy --> DB["db (PyMongo)"]
    API --> DB
    API --> FlaskReq["flask.request / flask.json.jsonify"]
    %% Functions in the file
    API -.-> F1[get_items()]
    API -.-> F2[get_item()]
    API -.-> F3[add_item()]
    API -.-> F4[remove_item()]
```

### 2) Data / control flow (combined: Item Retrieval & Item Addition)
```mermaid
graph TD
    C["Client HTTP Request"] --> R["Route Handler (api_routes_bp)"]
    R --> CheckParam{"Which endpoint?"}
    CheckParam -->|getItemWithId| ValidateId["Validate id with ObjectId.is_valid"]
    ValidateId -->|Invalid| RetInvalid["Return: {\"message\": \"Not a valid id\"}"]
    ValidateId -->|Valid| DbFindOne["db.items.find_one({_id: ObjectId(id)})"]
    DbFindOne -->|Found| RetFound["Return: 200 with 'message' and 'item' (stringified)"]
    DbFindOne -->|Not Found| RetNotFound["Return: {\"message\":\"No item present with that id\"}"]
    CheckParam -->|addItem| ReadItemParam["Read 'item' query param"]
    ReadItemParam -->|Missing| RetNoItem["Return: {\"message\":\"No item provided to add\"}"]
    ReadItemParam -->|Present| EvalParse["Parse via eval(item)  (unsafe)"]
    EvalParse -->|Parsed| DbInsert["db.items.insert_one(item)"]
    DbInsert --> RetAddSuccess["Return: Item successfully added to the cart"]
```

---

## Operational notes & pitfalls (implementation facts)
- All operations use HTTP GET and query parameters; mutations (`addItem`, `removeItem`) are implemented as GET — this affects caching and idempotency expectations.
- `add_item` uses `eval` to parse user input. This is a critical security risk (remote code execution) when the service processes untrusted input.
- `get_item` returns the found document as `str(item)` rather than JSON-serializing the document with `_id` converted to string. This reduces client usability and JSON fidelity.
- `remove_item` converts `id` to `ObjectId` without prior `ObjectId.is_valid` check; invalid ids may raise runtime exceptions.
- The module assumes `db` (PyMongo) is provided by `app.py`. Remove duplicate imports of `ObjectId` if present.

---