# Configuration management and environment settings

## Summary
This subtopic documents how runtime configuration and environment settings are managed for the flask-shopping-cart-rest-api project, how they are consumed by the bootstrap (app.py), PyMongo, API routes, tests and WSGI servers, and recommended patterns to improve testability and deployment. Primary configuration variables: `MONGO_URI` (required) and `FLASK_DEBUG` (optional). Core exports in the current codebase: `app` (Flask instance) and `db` (PyMongo handle).

## Key Abstractions
- **Module-level Bootstrap (singleton pattern)**  
  - app.py performs one-time application initialization at module import: reads env vars, sets `app.config`, initializes extensions (`PyMongo(app)`), exposes global `db` and `app`. Simple, works for single-process local run but couples modules and complicates parallel tests.

- **Extension Initialization (Flask extension pattern)**  
  - PyMongo is initialized with the Flask app to create a pooled `mongo` client and `db` handle: `mongo = PyMongo(app)` → `db = mongo.db`. This provides a shared DB handle consumed by route modules.

- **Application Factory (recommended pattern)**  
  - `create_app(config=None)` builds and returns app instances with per-instance extension initialization (`PyMongo()` called with the app or `init_app`). Enables isolated test instances, per-environment configs, and avoids module-level side effects.

## Collaborative Use Case
How the relevant files and runtime actors collaborate to provide configuration and DB access.

Files and runtime actors (examples referenced in docs):
- flask-shopping-cart-rest-api/app.py — current bootstrap: reads env vars, sets `app.config['MONGO_URI']`, creates `PyMongo(app)`, exposes `app` and `db`.
- flask-shopping-cart-rest-api/api/api_routes.py — imports `db` (current pattern) and defines route handlers that call MongoDB collections.
- Tests (e.g., tests/test_api.py) — import `app` and `db` to seed test data and use `app.test_client()` to exercise endpoints.
- WSGI servers — import `app` to run (e.g., `gunicorn -w 4 'app:app'`).

Concrete code examples (current pattern)
```python
# app.py (current, module-level bootstrap)
import os
from flask import Flask
from flask_pymongo import PyMongo

app = Flask(__name__)
app.config['MONGO_URI'] = os.environ.get('MONGO_URI')  # required at startup
app.config['DEBUG'] = bool(int(os.environ.get('FLASK_DEBUG', '0')))

mongo = PyMongo(app)
db = mongo.db  # exported shared handle

from api.api_routes import api_routes_bp
app.register_blueprint(api_routes_bp, url_prefix='/api')
```

```python
# api/api_routes.py (current pattern)
from flask import Blueprint, jsonify, request
from app import db  # module-level import of shared db handle

api_routes_bp = Blueprint('api', __name__)

@api_routes_bp.route('/items', methods=['GET'])
def list_items():
    items = list(db.items.find())
    return jsonify(items)
```

Recommended factory-based refactor (example)
```python
# factory.py (recommended)
import os
from flask import Flask
from flask_pymongo import PyMongo

def create_app(config=None):
    app = Flask(__name__)
    if config:
        app.config.update(config)
    else:
        app.config['MONGO_URI'] = os.environ.get('MONGO_URI')
        app.config['DEBUG'] = bool(int(os.environ.get('FLASK_DEBUG', '0')))

    mongo = PyMongo()
    mongo.init_app(app)  # per-app extension init
    from api import api_routes  # import after app exists
    app.register_blueprint(api_routes.api_routes_bp, url_prefix='/api')

    # store mongo instance on app for handlers or tests to access
    app.extensions['pymongo'] = mongo
    return app
```

Route usage after factory refactor
```python
# api/api_routes.py (refactored)
from flask import Blueprint, current_app, jsonify

api_routes_bp = Blueprint('api', __name__)

def get_db():
    mongo = current_app.extensions['pymongo']
    return mongo.db

@api_routes_bp.route('/items', methods=['GET'])
def list_items():
    db = get_db()
    items = list(db.items.find())
    return jsonify(items)
```

Test snippet using factory pattern
```python
# tests/test_api.py
from factory import create_app

def test_list_items(monkeypatch):
    app = create_app({'MONGO_URI': 'mongodb://localhost:27017/shoppingcart_test', 'DEBUG': False})
    client = app.test_client()
    # obtain db via app context and seed data
    with app.app_context():
        db = app.extensions['pymongo'].db
        db.items.insert_one({'name': 'test'})
    resp = client.get('/api/items')
    assert resp.status_code == 200
```

## Application Flow Integration
This subtopic enables the following key flows:

1. Application Startup
   - Read environment (MONGO_URI, FLASK_DEBUG)
   - Configure Flask app
   - Initialize PyMongo extension and create `mongo` connection pool
   - Register Blueprints and make `app` ready for WSGI

2. Request Routing and DB Lifecycle
   - WSGI server forwards requests to `app`
   - Route handlers obtain `db` (module-level import or via app context)
   - Handlers execute queries against MongoDB through PyMongo client
   - PyMongo manages connection pooling across requests

3. Testing and CI
   - Tests either import `app`/`db` (current pattern) or call `create_app(test_config)` (factory)
   - Tests seed and teardown test DB collections or use a mock (e.g., mongomock)
   - CI injects test-specific `MONGO_URI` or configures a mock DB for deterministic runs

## Configuration Variables & Recommended Defaults
- MONGO_URI (required)  
  - Purpose: MongoDB connection string for PyMongo  
  - Example: `mongodb://localhost:27017/shoppingcart` or `mongodb+srv://user:pass@cluster0.example.mongodb.net/shoppingcart?retryWrites=true&w=majority`  
  - Notes: Provide via environment or secrets manager; do not hard-code. For tests use a dedicated test DB URI or mongomock.

- FLASK_DEBUG (optional)  
  - Purpose: Enable Flask debug/reloader mode  
  - Example: `export FLASK_DEBUG=1`  
  - Notes: Treat as boolean; never enable in production.

Operational guidance
- Use environment variables or secret managers for all credentials and production URIs.
- Validate presence of required env vars early in startup and fail fast if missing.
- Tune PyMongo pool settings (e.g., `maxPoolSize`) when using many WSGI workers to avoid connection exhaustion.
- Do not run `app.run(debug=True)` in production.

## Common Pitfalls & Mitigations
- Hard-coded MONGO_URI → use environment or secret manager.
- Global `db` coupling → refactor to application factory; use app context to obtain DB.
- Tests mutating production DB → ensure CI/tests use isolated test DB or mocks.
- Connection pool exhaustion → align gunicorn worker count and PyMongo pool size with DB capacity.
- Circular imports → defer blueprint imports until after app creation or use factory pattern.

## Visual Diagrams

### File collaboration (imports/exports)
```mermaid
graph TD
    app_py["flask-shopping-cart-rest-api/app.py"] -->|exports app, db| api_routes["flask-shopping-cart-rest-api/api/api_routes.py"]
    app_py -->|imported by| tests["tests/test_*.py"]
    app_py -->|imported by| wsgi["WSGI Server (gunicorn/uWSGI)"]
    docs["flask-shopping-cart-rest-api/docs/05-Application-Configuration-and-Infrastructure.md"] -.-> app_py
    api_routes -->|uses db| app_py
    tests -->|seed/read db| app_py
```

### Data and control flow (startup → request → db → response)
```mermaid
graph TD
    start["Start: process launches (gunicorn/test)"] --> readenv["Read env: MONGO_URI, FLASK_DEBUG"]
    readenv --> configure["Configure Flask app (app.config)"]
    configure --> pymongo_init["Init PyMongo (PyMongo(app) or init_app)"]
    pymongo_init --> mongo["MongoDB connection pool (PyMongo)"]
    mongo --> db_handle["db (mongo.db) exported or available via app.extensions"]
    client_request["Client or test_client request"] --> wsgi_server["WSGI server / test client"]
    wsgi_server --> app["Flask app"]
    app --> route["api/api_routes.py handler"]
    route -->|uses db_handle| db_handle
    db_handle --> mongo_server["MongoDB server"]
    mongo_server --> db_result["Query result"]
    db_result --> route
    route --> response["HTTP response returned to client"]
```

## Implementation Checklist & Recommended Steps
1. Add a configuration utility to read and validate required environment variables (fail fast on missing `MONGO_URI`).
2. Implement `create_app(config=None)` and migrate extension initialization into the factory; expose `mongo` via `app.extensions['pymongo']`.
3. Update route modules to use `current_app.extensions['pymongo'].db` (or provide a helper `get_db()`).
4. Update tests to call `create_app(test_config)` and use a dedicated test DB or mongomock; add fixtures to seed and teardown data.
5. Update deployment and CI pipelines to inject `MONGO_URI` and other secrets from environment or secret manager.
6. Tune PyMongo pool settings in production and coordinate with WSGI worker count.

## Maintenance Notes
- Update this document when refactoring to the application factory pattern (remove references to module-level `db` exports).
- Keep example MONGO_URI strings current with any auth mechanism or cluster types used (replica set, SRV/Atlas).
- Document test DB setup and include optional `.env.sample` for local development (without secrets).